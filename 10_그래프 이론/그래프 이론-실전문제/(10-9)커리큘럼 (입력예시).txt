cd C:\Users\choon\OneDrive\Desktop\PythonCodingTest\10_그래프 이론\그래프 이론-실전문제
python "커리큘럼.py"

( 입력 예시 )
5
10 -1
10 1 -1
4 1 -1
4 3 1 -1
3 3 -1

 (출력 예시 )
 10
 20
 14
 18
 17

( 문제 풀이흐름 )

1. 노드개수(강의 수) 입력받기
   - 모든 노드에 대한 진입 차수 '0'으로 초기화, 
   - 각 노드에 연결된 '간선 정보'를 담기 위한 연결 리스트 그래프 초기화. 
   - 각 [ 강의 시간을 ] '0'으로 초기화
------------------------------------------------------------------------------------------------------------------

2. 방향 그래프의 [ 모든 간선 정보 ]를 입력받기
(코드 부분 )
for i in range(1, v + 1):
    data = list(map(int, input().split()))
    time[i] = data[0] # 첫 번째 수는 [ 시간 정보 ]를 담고 있음
   
    for x in data[1:-1]: # 인덱스 '1'부터 '-2'요소(끝 원소 제외한 나머지) 까지 . ex) 10 1 -1 이면 '1' 만 출력. 
        indegree[i] += 1
        graph[x].append(i) # 방향성 도식화

( 테이블 표 )
time(강의시간) 리스트                                      indegree(진입차수) 리스트 
1    2    3    4   5                                            1       2        3        4      5
-------------------------------                             -----------------------------------
10  10  4     4   3                                             0      1         1       2      1

----------------------------------------------------------------------------------------------
graph(방향 도식화) 리스트 
0           1             2                 3                       4           5
[ ]       (2,3,4)           [ ]               (4 , 5)               [ ]           [] 
-----------------------------------------------------------------------------------------------------------------

3. 위상 정렬 수행 topology_sort()

-----------------------------------------------------------------------------------------------------------------

4.  deepcopy함수를 통하여 --> 'time(강의 시간) 리스트' 변수의 값을 [ 복사 ].
    result = copy.deepcopy(time) # 알고리즘 [ 수행 결과 ]를 담을 리스트
-----------------------------------------------------------------------------------------------------------------

5. 큐 기능을 위해 deque 라이브러리 사용. 그 후 진입 차수가 '0'인 노드를 [ 큐에 삽입. ]

(해당 코드 부분 )
    q = deque() # '큐 기능'을 위한 deque 라이브러리 사용

    # 처음 시작할 때는 [ 진입차수가 0인 노드 ]를 '큐에 삽입'
    for i in range(1, v + 1):
        if indegree[i] == 0:
            q.append(i)
-----------------------------------------------------------------------------------------------------------------
6.  큐가 '빌 때까지' 반복
     (1). 먼저 큐에서 원소를 꺼내서 now 변수에 저장.
     (2). 그래프 방향성 도식화 한 것중 [ 현재 원소와 연결된 노드들의 최소 시간을 저장 ]
           - [ 해당 원소와 ] 연결된 ' 노드들의 진입차수 '에서 '1 빼기'
           - 새롭게 [ ** 진입차수 **가 '0이' 되는 노드를 ] '큐에 삽입'
( 코드 부분)              
   # 큐가 '빌 때까지' 반복
    while q:
        # 큐에서 원소 꺼내기
        now = q.popleft()
        # [ 해당 원소와 ] 연결된 ' 노드들의 진입차수 '에서 '1 빼기'
        for i in graph[now]:
            result[i] = max(result[i], result[now] + time[i]) --> 현재보다 강의시간이 더 긴경우를 찾아야 함.( 선수 과목을 수강하고 듣기 때문 )
            indegree[i] -= 1
            # 새롭게 [ ** 진입차수 **가 '0이' 되는 노드를 ] '큐에 삽입'
            if indegree[i] == 0:
                q.append(i)
---------------------------------------------------------------------------------------------------------------------------------------------------
( 현재 테이블 표 )
time(강의시간) 리스트                                      result(각 강의 수강 시간) 리스트 -- time 리스트 복사한 상태.
1    2    3    4   5                                            1       2        3        4      5
-------------------------------                             -----------------------------------
10  10  4     4   3                                           10     10       4       4      3 


[ result 갱신 테이블 상태 ] --> 매번 간선 정보를 확인하여 결과 테이블 갱신
       1    2     3    4    5
i=2 [10, 20,   4,   4,   3]   -- now =1       -->1이랑 연결된 노드와의 간선 정보를 확인하여 갱신.
i=3 [10, 20,  14,  4,   3]   -- now =1        --> result[3](4) = max(result[3], result[1](10) + time[3](4)) = 14
i=4 [10, 20, 14,  14,  3]   -- now =1   --> 1번에서 4번강의를 듣기위한 수강 최소 시간 '14'

i=4 [10, 20, 14,  18,  3]   -- now = 3
i=5 [10, 20, 14,  18, 17]  -- now = 3
-----------------------------------------------------------------------------------------------------------------

7. 위상 정렬을 수행한 [ 결과 출력 ]
    for i in range(1, v + 1):
        print(i , "번 강의 수강 최소 시간: ",result[i])