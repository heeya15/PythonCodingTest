"""
(실전 문제) 전보 p, 262
- 어떤 나라에는 N개의 도시가 있다. 
  그리고 각 도시는 보내고자 하는 메시지가 있는 경우, 다른 도시로 전보를 보내서 
  다른 도시로 해당 메시지를 전송할 수 있다
- 하지만 ' X라는 도시 '에서 ' Y라는 도시 '로 [ 전보를 보내고자 한다면 ],
  도시 [ X에서 Y로 향하는 " 통로 " ]가 ' 설치되어 있어야 한다. '

- 예를 들어 X에서 Y로 향하는 통로는 있지만, [ Y에서 X로 향하는 ] ' 통로가 없다면 ' 
  [ [ Y는 ] --> [ X로 ] 메시지를 보낼 수 없다. ]
 또한 [ 통로를 거쳐 메시지를 보낼 때 ]는 " 일정 시간이 소요 "된다.

- 어느 날 'C라는 도시'에서 [ 위급 상황이 발생 ]했다. 그래서 [ 최대한 많은 도시로 메시지를 보내고자 ] 한다.
메시지는 [ 도시 C에서 출발 ]하여 ' 각 도시 사이에 설치된 통로를 거쳐 ', [ 최대한 많이 퍼져나갈 것 ]이다

- [ 각 도시의 번호 ]와 [ 통로가 설치되어 있는 정보가 주어졌을 때 ], 
  [ 도시 C에서 ] 보낸 메시지를 받게 되는[  도시의 개수는 ] 총 몇 개이며 
  [ 도시들이 모두 메시지를 받는 데 ] 까지 ' 걸리는 시간 '은 얼마인지 계산하는 프로그램을 작성하라

------------------------------------------------------------------------------
[ 입력 조건 ]

- 첫째 줄에 " 도시의 개수 [ N ]과" "통로의 개수 [ M ]", 메시지를 [ 보내고자 하는 도시 C가 ] 주어진다.
 
  (1 <= N <= 30,000, 1<= M <=200,000, 1 <= C <= N)

- 둘째 줄부터 [ M+1번째 줄 ]에 걸쳐서 [ 통로에 대한 정보 X,Y,Z ]가 주어진다.
  이는 < '특정도시 X' >에서 ' < 다른 특정도시 Y로 이어지는 통로 ' >가 있으며, 
  < '메시지가 전달되는 시간이 Z' >라는 의미
  (1 <= X, Y <= N, 1 <= Z <= 1,000)


[ 출력 조건 ]

- 첫째 줄에 [ 도시 C에서 보낸 메시지를 받는 ] "도시의 총 개수"와 "총 걸리는 시간 "을 
  ' 공백으로 구분 '하여 출력한다.

[ 입력 ]                     [ 출력 ]
3 2 1
1 2 4
1 3 2                        2  4 -- > (메시지를 '받는' 도시의 총개수 = '2', 총 걸리는 시간 = '4')

------------------------------------------------------------------------------

( 문제 아이디어 )
- 핵심: 한 도시에서 다른 도시까지의 [ 최단 거리 문제 ]로 치환할 수 있다.

- N과 M의 범위가 충분히 크기 때문에 우선순위 큐를 활용한 다익스트라 알고리즘을 구현.
- 
"""
# 책 정답 9-5.py (p, 263 ) 

import heapq
import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

#  [ 노드 ]의 개수, [ 간선 ]의 개수, [ 시작 노드 ]를 입력받기
n, m, c = map(int, input().split())

# " 각 노드에 연결 "되어 있는 [ 노드에 대한 정보를 담는 리스트 ]를 만들기
graph = [[] for i in range(n + 1)]

# "최단 거리 테이블"을 [ 모두 무한 ]으로 초기화
distance = [INF] * (n + 1)

# 모든 [ ** 간선 정보(통로) ** ]를 입력받기
for _ in range(m):
    x, y, z = map(int, input().split())
    # [ X번 노드 ]에서 [ Y번 노드로 가는 비용 ]이 'Z라는 의미'
    graph[x].append((y, z))
    
    
def dijkstra(start):
   q = []
   # 첫 번째 인수는 heap으로 사용될 [ list가 들어가고 ] 두 번째 인수로는 [ 넣고자 하는 값 ]이 들어간다.
   # [ 시작 노드로 ] 가기 위한 [ 최단 경로는 0으로 설정 ]하여, [ 큐(q)리스트에 삽입 ]
   heapq.heappush(q, (0, start))
   distance[start] = 0 # [ 최단 거리 ]테이블 [출발노드] 거리값을 0으로 설정.
   
   while q: # 큐가 비어있지 않다면
        # 가장 [ 최단 거리가 짧은 노드 ]에 대한 [ 정보 꺼내기 ]
        dist, now = heapq.heappop(q)
        # 우선 순위 큐의 최단 거리 값 보다, 최단 거리테이블 거리 값이 더 작다면 무시해라 
        # 즉 , [ 현재 노드가 ] 이미 처리된 적이 있어 [ 작은 거리값이 들어간 상태 노드 ]라면 무시
        if distance[now] < dist:
            continue
        # 현재 노드와 연결된 다른 인접한 노드들을 확인
        for i in graph[now]:
            cost = dist + i[1] # 추출한 노드의 거리 + [ 걸쳐서 ] 해당노드로 가는 비용
            # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리(cost)가 더 짧은 경우
            if cost < distance[i[0]]:
                distance[i[0]] = cost # 짧은 거리를 최단 거리테이블에 갱신.
                heapq.heappush(q, (cost, i[0])) # 우선 순위 큐에, 갱신된 (최단 거리,노드) 튜플을 넣어줌.

# 다익스트라 알고리즘을 수행
dijkstra(c) # 메시지를 보내는 도시(시작 노드)를 인수로 줌.

print(sep='\n' )
print("출력 ")

# 도달할 수 있는 노드의 개수
count = 0
# 도달할 수 있는 [ 노드 중 ]에서, [ 가장 멀리 있는 노드 ]와의 최단 거리 추출 
max_distance = 0
for d in distance:
    # 도달할 수 있는 노드인 경우
    if d != INF:
        count += 1
        max_distance = max(max_distance, d)

# 시작 노드는 제외해야 하므로 count - 1을 출력
print(count - 1, max_distance)
