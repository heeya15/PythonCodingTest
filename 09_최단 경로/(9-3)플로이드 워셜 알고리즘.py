"""
p, 251 ~ 256
(플로이드 워셜 알고리즘) 
- [ 모든 지점 ]에서 [ 다른 모든지점까지 ]의 최단 경로를 모두 구해야 하는 경우 사용

- 소스코드 또한 매우 짧아, 다익스트라 알고리즘과 비교하면 
  구현 과정에서 어려움을 겪지는 않을 것. 다만, 핵심 아이디어를 이해하는 것이 중요!
  
- 단계마다 '거쳐 가는 노드'를 기준으로 알고리즘을 수행.
  하지만, 매번 [ 방문하지 않은 노드 ] 중에서 [ ** 최단 거리를 갖는 노드를 찾을 필요가 없다 ** ]는 점.
  
- "다익스트라 알고리즘"에서는 [ 출발 노드가 1개 ] 이므로 다른 모든 노드까지의
  [ 최단 거리를 ] 저장하기 위해 [ 1차원 리스트를 이용 ]
  
- "플로이드 워셜 알고리즘"은 다익스트라 알고리즘과 다르게 [ 2차원 리스트에 '최단 거리' 정보를 저장.]
  [ 모든 노드에 대하여 ] '다른 모든 노드로 가는' [ 최단 거리 정보를 담아야 하기 때문. ]
  
- 다익스트라 알고리즘은 [ 그리디 알고리즘 ]
  플로이드 워셜 알고리즘은 [ 다이나믹 프로그래밍 ] 이라는 특징이 있다.
  
- (n-1)P(2)개의 쌍을 단계마다 반복해서 확인하면서 [ 최단 거리를 갱신 ]한다.
ex) [ 4개의 노드 중 ] "1번노드를 거쳐가는 경우"를 고려한다면, 6= (3 )P(2) 가지 경우에 대해서만 고민
    즉, ' 1번 노드를 제외 '한 [ 2,3,4번 노드 ]에서 1번노드를 거쳐 가는 [ 2개의 노드를 뽑는 경우를 고려. ]
    
"""
# 책 정답 9-3.py (p, 257~258 ) 

INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# [ 노드 ]의 개수, [ 간선 ]의 개수를 입력받기
n = int(input())
m = int(input())

# 2차원 리스트(그래프 표현)를 만들고, 모든 값을 '무한'으로 초기화
graph = [[INF] * (n + 1) for _ in range(n + 1)]


# 자기 자신에서 [ 자기 자신으로 가는 비용은 0으로 초기화 ]
for a in range(1, n + 1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

# 각 [ 간선에 대한 정보를 입력 ] 받아, 그 값으로 초기화
for _ in range(m):
    # [ a번 노드 ]에서 'b번 노드'로 가는 [ 비용이 'c'라는 의미 ]
    a, b, c = map(int, input().split())
    graph[a][b] = c


# '점화식에 따라' [ 플로이드 워셜 알고리즘을 수행 ]
for k in range(1, n + 1):
    for a in range(1, n + 1):
        for b in range(1, n + 1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])


print(sep='\n' )
print("출력 ")

# '모든 지점'에서 [ 다른 모든 노드로 ] 가기 위한 "최단 거리"를 출력
# 수행된 결과를 출력
for a in range(1, n + 1):
    for b in range(1, n + 1):
        # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
        if graph[a][b] == INF:
            print("INFINITY", end=" ")
        # 도달할 수 있는 경우 거리를 출력
        else:
            print(graph[a][b], end=" ")
    print()