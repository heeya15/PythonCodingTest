"""
문제:
    - 배열의 크기 [ N ], 
    - 숫자가 더해지는 횟수[  M ]
    - 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.
    - K는 [ 특정한 인덱스의 수가 연속해서 더해지는 횟수 ] 
< 입력조건 >
- [ 첫째 줄 ]에 N(2<= n <= 1,000), 
               M(1<=M <= 10,000), 
               K(1<= K <= 10,000)의 자연수가 주어지며
               [ 각 자연수는 ] [ 공백으로 구분 ]한다.
- [ 둘째 줄에 ] N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다
  단, 각각의 자연수는 1이상 10,000 이하의 수로 주어진다.
- 입력으로 주어지는 [ K는 ] 항상 [ M보다 작거나 같다 ].

< 출력 조건 >
- 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

< 입력 예시 >                  < 출력 예시 >
5 8 3                             46
2 4 5 4 6                
  
배열의 크기(N) = 5,  숫자가 더해지는 횟수(M) = 8, 
특정한 인덱스의 수가 연속해서 더해지는 횟수(K) = 3   --> 8 / (3+1) == 2 로 나눈 [몫]이 수열의 반복되는 횟수.

< ** 만약 ** > 
n, m , k 를 5 , 9 ,3 입력.
9 / (3+1) 은 나누어 떨어지지 않는다.
이럴때는 m을 (k+1)로 나눈 [ 나머지만큼 ] 가장 큰 수가 추가로 더해지므로 고려!
-----------------------------------------------------------------------------------------
< map 내장 함수 >
파이썬의 내장 함수인 map()는 [ 여러 개의 데이터를 ] 
[ 한 번에 다른 형태로 변환 ]하기 위해서 사용됩니다. 
따라서, 여러 개의 데이터를 담고 있는 list나 tuple을 대상으로 주로 사용하는 함수입니다.
"""

#아래는 -->  M이 (K+1)로 나누어 떨어지지 않는경우 푸는 방법 !!

# N, M, K를 공백을 기준으로 구분하여 입력 받기
n, m, k = map(int, input().split())
# N개의 수를 공백을 기준으로 구분하여 입력 받기
data = list(map(int, input().split()))

data.sort() # 입력 받은 수들 오름차순 정렬하기
first = data[n - 1] # 가장 큰 수
second = data[n - 2] # 두 번째로 큰 수

# 가장 큰 수가 더해지는 횟수 계산
# int(m / (k + 1))은 파이썬에서 '몫' 을 구하기 위해 이용 --> 다른 방법으로는 m// (k+1)과 같다.
count = int(m / (k + 1)) * k   # (9 // 4) *3 = 6 

count += m % (k + 1)  # 6 + (9 % (3+1)) = 7

result = 0
result += (count) * first # 가장 큰 수 더하기 
result += (m - count) * second # 두 번째로 큰 수 더하기 ( 9- 7 = 2)

print(result) # 최종 답안 출력

#-----------------------------------------------------------------------------------------
'''
# 아래는 ) 나만의 가장 큰 수를 만드는 방법 풀이 예시)
# N, M, K를 공백을 기준으로 구분하여 입력 받기
n, m, k = map(int, input().split())
# N개의 수를 공백을 기준으로 구분하여 입력 받기
data = list(map(int, input().split()))

data.sort() # sort함수 안에 --> reverse옵션 True는 [ 내림차순 ] 정렬

first_max = data[n - 1] # 가장 큰 수 
second_max = data[n - 2] # 두 번째로 큰 수 

result = 0
count = 0

for i in range(m):  #0부터 9 미만의 숫자를 포함 -- [ 총 9번 반복하여 가장 큰 수를 만든다.]
    if count != k: # 횟수가 != 가장 큰 수가 연속해서 [ 더해지는 횟수 ]와 같지 않은경우 
        result += first_max # 가장 큰 수 더하기
        count += 1 # 가장 큰 수 더할 때마다 횟수 +1
    else:
        result += second_max # 두 번째로 큰 수 더하기  
        count = 0 # 횟수 0으로 초기화. 

print(result) # 최종 답안 출력.

'''