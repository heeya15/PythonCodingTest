"""
# p,212
- [ 메모이제이션 ]은 다이나믹 프로그래밍을 구현하는 [ 방법 중 한 종류 ]로,
  ★ 한 번 구한 결과 ★를 < 메모리 공간에 메모 >해두고 
  [ 같은 식을 다시 호출 ]하면 [ 메모한 결과를 그대로 가져오는 기법 ]이다.
  
- [ 메모이제이션은 ] ' 값을 저장하는 방법 '이므로 '캐싱(Caching)'이라고도 한다.
  구현 방법은 단순하다.
  [ 한 번 구한 정보 ]를 --> ' 리스트에 저장 '하는 것이다.
- 즉, 한번 구한 정보를 리스트에 저장하는 것.  
  다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때는 
  [ 이미 구한 정답을 ] 그대로 리스트에서 가져오면 된다.
  이를 소스코드로 나타내면 아래와 같다.
※ 정리하자면, 다이나믹 프로그래밍이란 ?
   [ 큰 문제를 ] 작게 나누고, 
   [ 같은 문제 ]라면 " 한 번씩만 풀어 "--> 문제를 효율적으로 해결하는 알고리즘 기법
"""
# 8-2.py 피보나치 수열 소스코드 (재귀적)
# 사실상 이미구한 결과의 값을 가져오거나 바로 1을 반환하는 형태여서
# [ 이미구한 노드의 값을 ] 호출되지 않는다고 이해하자!
# 한 번 계산된 결과를 < 메모이제이션(Memoization)하기 > 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현 ('탑다운' 다이나믹 프로그래밍)
def fibo(x):
    
    # 종료 조건('1 혹은 2일 때 ' 1을 반환)
    if x == 1 or x == 2:
        return 1
    # [ 이미 계산한 적 있는 문제 ]라면 그대로 반환
    if d[x] != 0:
       return d[x]
    
    # 아직 [ 계산하지 않은 문제 ]라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))
'''
# 물론 [ 재귀 함수를 사용 ]하면 컴퓨터 시스템에서는 함수를 다시 호출했을 때 
  [ 메모리 상에 적재되는 일련의 과정을 따라야 ] 하므로 [ 오버헤드가 발생할 수 있다 ].
  
  --> 따라서 재귀 함수 대신에 " 반복문을 사용 "하여 [ 오버헤드를 줄일 수 있다. ]
★ 일반적으로 [ 반복문을 이용한 ] '다이나믹 프로그래밍이 ' < 더 성능이 좋기 때문 >이다.
'''