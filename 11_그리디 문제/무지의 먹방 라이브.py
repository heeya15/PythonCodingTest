"""
(실전 문제) 볼링공 고르기 p, 315 

- A, B두 사람이 볼링을 치고 있습니다. 두 사람은 서로 [ 무게가 다른 골링공 ]을 고르려고 합니다. 

- 볼링공은 [총 N개 ]가 있으며 각 볼링공마다 무게가 적혀 있고, [ 공의 번호는 ] 1번부터 순서대로 부여됩니다.

- 또한 [ 같은 무게의 공이 여러 개 ] 있을 수 있지만, [ 서로 다른 공 ]으로 간주하빈다. 
  [ 볼링공의 무게 ]는 [ 1부터 M까지의 자연수 형태 ]로 존재합니다.

- 예를 들어 'N이 5'이고, 'M이 3'이며 [ 각각의 무게가 차례대로 ] 1, 3, 2, 3, 2 일 때 
  [ 각 공의 번호가 ] 차례대로 1번부터 5번까지 부여됩니다. 
  이때 두 사람이 고를 수 있는 [ 볼링공 번호의 조합 ]을 구하면 다음과 같습니다.

 (1번, 2번)(1번, 3번)(1번, 4번) (1번, 5번) (2번, 3번)(2번, 5번)(3번, 4번) (4번, 5번)
 결과적으로 [ 두 사람이 공을 고르는 경우의 수 ]는 '8가지' 입니다.

- [ N개의 공의 무게가 ] 각각주어질 때, 두 사람이 [ 볼링공을 고르는 경우의 수 ]를 구하는 프로그램을 작성하세요.

[ 입력 조건 ]
- [ 첫째 줄 ]에 '볼링공의 개수 N', [ 공의 최대 무게 M이 ] 공백으로 구분되어 [ 각각 자연수 형태 ]로 주어집니다. 
  (1 <= N <= 1,000, 1 <= M <=10)
  
- [ 둘째 줄 ]에 각 [ 볼링공의 '무게 K'가 공백으로 구분 ]되어 순서대로 자연수 형태로 주어집니다.
   
[ 출력 조건 ]
- 첫째 줄에 두 사람이 [ 볼링공을 고르는 경우의 수 ]를 출력합니다.

( 입력 예시 )                         ( 출력 예시 1)
5 3
1 3 2 3 2                                 8
---------------------------------------------------------
                                     ( 출력 예시 2)
8 5
1 5 4 3 2 4 5 2                           25

"""
# 내가 푼 방법.
n, m = list(map(int,input().split()))

k = list(map(int,input().split()))

result = 0

# a가 먼저 하나를 고른 뒤 나머지 중에 b가 고를수 있는 경우의 수를 더해줌.

for i in range(len(k)):
    for j in range(i+1,len(k)):
        if k[i] == k[j]: # 같은 무게인 경우는 제외함.
            continue
        result +=1
        
print(result)   
'''
import heapq

def solution(food_times, k):
    # 전체 음식을 먹는 시간보다 k가 크거나 같다면 -1
    if sum(food_times) <= k:
        return -1

    # 시간이 작은 음식부터 빼야 하므로 우선순위 큐를 이용
    q = []
    for i in range(len(food_times)):
        # (음식 시간, 음식 번호) 형태로 우선순위 큐에 삽입
        heapq.heappush(q, (food_times[i], i + 1))  

    sum_value = 0 # 먹기 위해 사용한 시간
    previous = 0 # 직전에 다 먹은 음식 시간
    length = len(food_times) # 남은 음식의 개수

    # sum_value + (현재의 음식 시간 - 이전 음식 시간) * 현재 음식 개수와 k 비교
    while sum_value + ((q[0][0] - previous) * length) <= k:
        now = heapq.heappop(q)[0]
        sum_value += (now - previous) * length
        length -= 1 # 다 먹은 음식 제외
        previous = now # 이전 음식 시간 재설정

    # 남은 음식 중에서 몇 번째 음식인지 확인하여 출력
    result = sorted(q, key=lambda x: x[1]) # 음식의 번호 기준으로 정렬
    return result[(k - sum_value) % length][1]
'''