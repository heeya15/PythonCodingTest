cd C:\Users\choon\OneDrive\Desktop\PythonCodingTest\11_그리디 문제
python "무지의 먹방 라이브.py"
(문제) p, 316~ 317

- 평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 [ 카카오 TV 라이브로 방송 ]을 하기로 마음먹었다.
  그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 [ 독특한 방식을 생각 ]해냈다.

- 회전판에 [ 먹어야 할 N 개의 음식 ]이 있다.
  각 음식에는 [ 1부터 N 까지 번호 ]가 붙어있으며, 각 음식을 섭취하는데 [ 일정 시간이 소요 ]된다.
  무지는 다음과 같은 방법으로 음식을 섭취한다.
  
1. 무지는 [ 1번 음식부터 먹기 시작 ]하며, '회전판'은 [ 번호가 증가하는 순서대로 ] 음식을 무지 앞으로 가져다 놓는다.

2. [ 마지막 번호의 음식을 섭취한 후 ]에는 회전판에 의해 [ 다시 1번 음식이 무지 앞 ]으로 온다.
  
3. 무지는 [ 음식 하나를 1초 동안 섭취 ]한 후 [ 남은 음식은 그대로 두고 ], [ 다음 음식을 섭취 ]한다.
   [ 다음 음식이란 ], 아직 [ 남은 음식 중 다음으로 섭취해야 할 ] [ 가장 가까운 번호의 음식 ]을 말한다.

4. ' 회전판이 다음 음식을 무지 앞으로 ' [ 가져오는데 걸리는 시간은 없다고 가정 ]한다.

- 무지가 먹방을 시작한 지 [ K 초 후에 ] 네트워크 장애로 인해 [ 방송이 잠시 중단 ]되었다.
  무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다.

- 각 음식을 모두 먹는데 [ 필요한 시간이 담겨있는 ] 배열 'food_times',
  [ 네트워크 장애가 발생한 시간 K 초가 ] 매개변수로 주어질 때 
  [ 몇 번 음식부터 다시 섭취하면 되는지 ] return 하도록 solution 함수를 완성하라.

[ 제한사항 ]
  - 'food_times 는' [ 각 음식을 모두 먹는데 필요한 시간 ]이 [ 음식의 번호 순서대로 들어있는 배열 ]이다.
  - ' k 는 ' 방송이 [ 중단된 시간 ]을 나타낸다.
  - 만약 [ 더 섭취해야 할 음식이 없다면 ] '-1을 반환' 하면 된다.

[ 정확성 테스트 제한 사항 ]
  - food_times 의 길이는 1 이상 2,000 이하이다.
  - food_times 의 원소는 1 이상 1,000 이하의 자연수이다.
  - k는 1 이상 2,000,000 이하의 자연수이다.

[ 효율성 테스트 제한 사항 ]
  - food_times 의 [ 길이 ]는 1 이상 200,000 이하이다.
  - food_times 의 [ 원소 ]는 1 이상 100,000,000 이하의 자연수이다.
  - k는 1 이상 2 x 10^13 이하의 자연수이다.

(입출력 예)

food_times	k	result
[3, 1, 2]	5	1

( 입출력 예시에 대한 설명 )

0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.
1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.
2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.
3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.
4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.
5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 [ 1번 음식부터 다시 먹기 시작 ]하면 된다.
( 아이디어 )

- 단계가 진행됨에 따라 'B의 경우의 수는 ' 줄어듬 --> 이미 계산했던 경우 (조합)는 제외하기 때문.
  ex) 전체 볼링공 개수에서,   [ A의 무게가 i인 볼링공을 선택할 수 있는 개수 ]를 제외해 준다.   --> 이것이 B가 선택하는 경우의 수.

- 각 무게별로 [ 볼링공이 몇 개가 존재하는지 기록 ]할 수 있다. 

 ex) 각 볼링공의 무게 1 3 2 3 2 이라고 할 시
    무게가 1인 볼링공 = 1개
    무게가 2인 볼링공 = 2개
    무게가 3인 볼링공 = 2개
    1. A가 무게가 1인 공을 선택할 때 경우의 수 -> 1 * 4 ( B가 선택할 수 있는 경우의 수 5-1) = 4 
    2. A가 무게가 2인 공을 선택할 때 경우의 수 -> 2 * 2 ( B가 선택할 수 있는 경우의 수 4-2) = 4
    3. A가 무게가 3인 공을 선택할 때 경우의 수 -> 2 * 0 ( B가 선택할 수 있는 경우의 수 2-2) = 0
    => 8가지

( 문제 풀이흐름 )
- 수행시간이 '제한된 상황'에서 heapq를 사용하는 것을 권장.
- 우선순위 큐는 [ 최소 힙 구조 ]를 이용, 그러나 q에 (음식 시간, 음식 번호) 형태로 
  우선순위 큐에 삽입 하였는데, 내 생각 대로면 큐에 [(3, 1), (1, 2), (2, 3)] -- 순으로 들어가야 하는데, 
  [(1, 2), (3, 1), (2, 3)] 순으로 들어가 있다.
  아직까지 이해가 되질 않지만 '꺼낼때는 가장 작은 데이터를 먼저 꺼내기 때문에' 넘어갔다.
print(q)   --> [(1, 2), (3, 1), (2, 3)]
print(q[0][0],q[0][1])  --> 1 2
print(q[1][0],q[1][1])  --> 3 1
print(q[2][0],q[2][1])  --> 2 3

- 음식을 모두 먹는데 필요한 시간들의 합이 [ k보다 작거나 같을 경우 ]에는 
  다음에 먹을 음식이 없기 때문에 -1을 리턴하는 방어 코드를 먼저 작성했다.
  즉, [ 중단 될 시간안에 ] 음식을 다 먹는다면, 다음에 먹을 음식이 없어서 '-1'을 반환.

- 그리고 일반적인 구현으로 쉽게 문제를 풀 수 있지만 해당 문제에서는 [ 효율성 체크를 요구 ]하고 있기 때문에 
  [ 하나하나씩 반복하면서 체크해서는 ] 시간 초과가 나버린다.

- 음식을 [ 먹을때 걸리는 시간이 적은 것부터 꺼낼 수 있도록 ] '우선순위 큐'에 삽입한다. 
  --> 음식을 [ 시간별로 ] '오름차순 정렬'을 해 준것으로 볼 수 있다.

- 음식을 다 먹은 시간과 앞으로 [ 남은 음식을 먹을 시간이 ] < k보다 작거나 같다면 >
  현재 음식을 먹을 수 있는 것이기 때문에 while의 안쪽으로 들어가서 
  [ sum_value ]에 '(현재 먹는 음식(처음 시간 - 이전 시간) X 먹을 수 있는 음식(남은 음식 갯수)'의 개수만큼 더해준다.

- 그러면 [ 가장 적게 걸리는 음식을 다 먹었을 테고 ] ' 먹을 수 있는 음식(남은 음식)의 개수는 -1을 해주고',
  [ 현재의 음식을 먹은 시간을 저장 ]한다.

- 반복문을 돌다가 sum_value에 앞으로 먹을 수 있는 음식들의 시간이 [ k보다 커지면  ]
  [ 반복문을 나와서 ] 해당 음식들을 다시 [ index 순서대로 정렬 ]해준다.  --> [ 남은 음식 번호 ] 순으로 정렬을 해 준다.
 
- 그리고 [ 남은 음식에서 ] [남은 k만큼을 고려한 ] index 번호를 return 하면 풀이가 끝난다.

---------------------------------------------------------------------------------------------------------------
1. 볼링공, 최대무게, 각각의 볼링공의 무게 입력

(코드 부분)
n, m = map(int, input().split()) # 볼링공의 개수, 볼링공의 [ 최대 무게 ] 입력.
data = list(map(int, input().split())) # 볼링공 무게를 입력.

---------------------------------------------------------------------------------------------------------------
2. 1부터 10까지의 각 무게별로 [ 볼링공이 몇 개가 존재하는지 기록 ]할 수 있다. 

(코드 부분 )
array = [0] * 11

for x in data:
    # 각 무게에 해당하는 [ 볼링공의 개수 ] 카운트
    array[x] += 1

[ array 테이블 상황 ]
0 1 2 3 4 5 6 7 8 9 10
---------------------------   
   1 2 2

---------------------------------------------------------------------------------------------------------------

3. '1부터 m(최대무게) 까지 '의 [ 각 무게에 대하여 처리 ] -- 경우의 수 계산
    전체 개수 - [ 무게가 i인 ] 볼링공의 개수(A가 선택할 수 있는 개수) 제외 --> b의 경우의 수가 됨
    ( 'a의 경우의 수' * 'b의 경우의수' ) 계산한 결과를 result 변수에 누적.
   
( 코드 부분 )

result = 0

# 1부터 m(최대무게) 까지의 [ 각 무게에 대하여 처리 ]
for i in range(1, m + 1):
    n -= array[i] # [ 무게가 i인 ] 볼링공의 개수(A가 선택할 수 있는 개수) 제외
    result += array[i] * n # B가 선택하는 경우의 수와 곱해주기

print(result)