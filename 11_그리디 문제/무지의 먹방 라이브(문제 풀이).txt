cd C:\Users\choon\OneDrive\Desktop\PythonCodingTest\11_그리디 문제
python "무지의 먹방 라이브.py"
(문제) p, 316~ 317

- 평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 [ 카카오 TV 라이브로 방송 ]을 하기로 마음먹었다.
  그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 [ 독특한 방식을 생각 ]해냈다.

- 회전판에 [ 먹어야 할 N 개의 음식 ]이 있다.
  각 음식에는 [ 1부터 N 까지 번호 ]가 붙어있으며, 각 음식을 섭취하는데 [ 일정 시간이 소요 ]된다.
  무지는 다음과 같은 방법으로 음식을 섭취한다.
  
1. 무지는 [ 1번 음식부터 먹기 시작 ]하며, '회전판'은 [ 번호가 증가하는 순서대로 ] 음식을 무지 앞으로 가져다 놓는다.

2. [ 마지막 번호의 음식을 섭취한 후 ]에는 회전판에 의해 [ 다시 1번 음식이 무지 앞 ]으로 온다.
  
3. 무지는 [ 음식 하나를 1초 동안 섭취 ]한 후 [ 남은 음식은 그대로 두고 ], [ 다음 음식을 섭취 ]한다.
   [ 다음 음식이란 ], 아직 [ 남은 음식 중 다음으로 섭취해야 할 ] [ 가장 가까운 번호의 음식 ]을 말한다.

4. ' 회전판이 다음 음식을 무지 앞으로 ' [ 가져오는데 걸리는 시간은 없다고 가정 ]한다.

- 무지가 먹방을 시작한 지 [ K 초 후에 ] 네트워크 장애로 인해 [ 방송이 잠시 중단 ]되었다.
  무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다.

- 각 음식을 모두 먹는데 [ 필요한 시간이 담겨있는 ] 배열 'food_times',
  [ 네트워크 장애가 발생한 시간 K 초가 ] 매개변수로 주어질 때 
  [ 몇 번 음식부터 다시 섭취하면 되는지 ] return 하도록 solution 함수를 완성하라.

[ 제한사항 ]
  - 'food_times 는' [ 각 음식을 모두 먹는데 필요한 시간 ]이 [ 음식의 번호 순서대로 들어있는 배열 ]이다.
  - ' k 는 ' 방송이 [ 중단된 시간 ]을 나타낸다.
  - 만약 [ 더 섭취해야 할 음식이 없다면 ] '-1을 반환' 하면 된다.

[ 정확성 테스트 제한 사항 ]
  - food_times 의 길이는 1 이상 2,000 이하이다.
  - food_times 의 원소는 1 이상 1,000 이하의 자연수이다.
  - k는 1 이상 2,000,000 이하의 자연수이다.

[ 효율성 테스트 제한 사항 ]
  - food_times 의 [ 길이 ]는 1 이상 200,000 이하이다.
  - food_times 의 [ 원소 ]는 1 이상 100,000,000 이하의 자연수이다.
  - k는 1 이상 2 x 10^13 이하의 자연수이다.

(입출력 예)

food_times	k	result
[3, 1, 2]	5	1

( 입출력 예시에 대한 설명 )

0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.
1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.
2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.
3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.
4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.
5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 [ 1번 음식부터 다시 먹기 시작 ]하면 된다.
--------------------------------------------------------------------------------------------------------------------------

( 아이디어 )

- 이 문제는 시간이 적게 걸리는 음식부터 확인하는 탐욕적 접근 방식으로 해결할 수 있다.
   모든 음식을 시간을 기준으로 정렬한 뒤에, [ 시간이 적게 걸리는 음식부터 ] ' 제거해 나가는 방식 '.

- 이를 위해 [ 우선순위 큐(heapq) ]를 이용하여 구현가능.

남은 시간 (k) = 5
남은 음식 : 3개

1번째 음식은 3초                                 1초  2번
2번째 음식은 1초    ==================>          2초  3번     
3번째 음식은 2초    ( 시간순으로 정렬 )           3초  1번

따라서, [ 우선 순위큐는 ] 항상 [ 가장 작은 원소가 제일 위에 ] 있다고 생각하면 된다.
그래서, [ 우선 순위큐에 ] 단순히 원소를 넣고, 빼는것 만으로도 [ 알아서 오름차순 정렬이 된 결과 ]가 나온다. (이정도 기억!)

1. 먼저 현재 처리해야할 음식의 시간은 1 초 * 남은음식(3) = 3 --> 즉, 한바퀴 돌았을때 시간이 3초 걸림.

2. 그러면 (남은시간(5) - 한바퀴 돌았을때 걸린 시간(3)) = 2
  <  현재 남은시간(k) = 2 , 남은 음식 = 2개  >, 먹은 음식 [ 2번 1초 ]
  현재 시간이 가장작은 원소 [ 2초 3번 음식 ]이 우선 순위큐 제일 위에 있는 상황이고,  
  즉, 첫번째 음식으로부터 시간이 얼마나 지났는지를 체크해야 한다.
  (현재 시간(2초) - 이전 시간(1초)) * 남은 음식(2) = 2 만큼 시간이 소비가 된다. 

3. 그러면 (남은시간(2) - 한바퀴 돌았을때 걸린 시간(2)) = 0 --> 남은 시간은 0초가 됨.
   남은 음식 1개 ( 1번음식 3초 ) --> 시간을 다 소비 했으니 중단 되었다가 [ 이어서 다시 먹을 음식은 1번 ]

-----------------------------------------------------------------------------------------------------------------------
( 문제 풀이흐름 )

- 수행시간이 '제한된 상황'에서 heapq를 사용하는 것을 권장.
- 우선순위 큐는 [ 최소 힙 구조 ]를 이용, 그러나 q에 (음식 시간, 음식 번호) 형태로 
  우선순위 큐에 삽입 하였는데, 내 생각 대로면 큐에 [(3, 1), (1, 2), (2, 3)] -- 순으로 들어가야 하는데, 
  [(1, 2), (3, 1), (2, 3)] 순으로 들어가 있다.
  아직까지 이해가 되질 않지만 '꺼낼때는 가장 작은 원소 데이터를 먼저 꺼내기 때문에' 넘어갔다.
print(q)   --> [(1, 2), (3, 1), (2, 3)]
print(q[0][0],q[0][1])  --> 1 2
print(q[1][0],q[1][1])  --> 3 1
print(q[2][0],q[2][1])  --> 2 3

1. 음식을 모두 먹는데 필요한 시간들의 합이 [ k보다 작거나 같을 경우 ]에는 
  다음에 먹을 음식이 없기 때문에 -1을 리턴
  즉, [ 중단 될 시간안에 ] 음식을 다 먹는다면, 다음에 먹을 음식이 없어서 '-1'을 반환.
( 코드 부분 )
 # [ 전체 음식을 먹는 시간보다 ] k가 크거나 같다면 -1 --> 다음에 먹을 음식이 없기 때문.
    # 즉, [ 중단 될 시간안에 ] 음식을 다 먹는다면, 다음에 먹을 음식이 없어서 '-1'을 반환.
    if sum(food_times) <= k:
        return -1
-----------------------------------------------------------------------------------------------------------------------
2. 음식을 [ 먹을때 걸리는 " 시간이 적게 걸리는 것부터 꺼낼 수 있도록" ] '우선순위 큐'에 삽입한다. 
  --> 음식을 [ 시간별로 ] '오름차순 정렬'을 해 준것으로 볼 수 있다.
[ 우선 순위큐에 ] 단순히 원소를 넣고, 빼는것 만으로도 [ 알아서 오름차순 정렬이 된 결과 ]가 나온다. (이정도 기억!)

( 코드 부분 )
 # [ 음식 시간이 작은 음식부터 ] 빼야 하므로 [ 우선순위 큐를 이용 ]
    q = []
    for i in range(len(food_times)):
        # (음식 시간, 음식 번호) 형태로 '우선순위 큐에 삽입'
        heapq.heappush(q, (food_times[i], i + 1)) 

-----------------------------------------------------------------------------------------------------------------------
3. 음식을 먹기위해 사용한 시간, 이전에 음식을 다 먹은시간, 남은 음식의 개수를 저장할 변수 선언
   현재 음식을 다 먹은 시간 + [ 남은 음식을 먹을 시간이 ](빼야될 값이) < k보다 작거나 같다면 >
   현재 음식을 [ 먹을 수 있는 것이기 때문에 while의 안쪽 ]으로 들어가서 
   시간이 적게 걸리는 음식 부터 확인 하면서,[ 현재의 음식 시간과 이전의 음식과의 시간차 만큼 ]에, 남아있는 음식의 갯수를 곱해준다.
   즉, [ sum_value ]에 '(현재 먹는 음식(처음 시간 - 이전 시간) X 먹을 수 있는 음식(남은 음식 갯수)'의 개수만큼 더해준다.

- 그러면 [ 가장 적게 걸리는 음식을 다 먹었을 테고 ] ' 먹을 수 있는 음식(남은 음식)의 개수는 -1을 해주고',
  [ 현재의 음식을 먹은 시간을 저장 ]한다.

- 반복문을 돌다가 sum_value + 앞으로 먹을 수 있는 음식들의 시간이 [ k보다 커지면  ] while문을 나온다.

(코드 부분)
# sum_value(먹기위해 사용한 시간) + {{(현재의 음식 시간 - 이전 음식 시간)} * 현재(남은) 음식 개수}와 [ k 비교 ]
    while sum_value + ((q[0][0] - previous) * length) <= k:  # 즉, 중단 될 시간과, 같거나, 작을 경우만 반복.       
        now = heapq.heappop(q)[0] # [ 시간이 적게 걸리는 음식 시간부터 ] 들고옴.
        # 그전의 먹은 음식의 시간차 (처음 시간 - 이전 시간) * 남은 음식 갯수. --> 이게 k에서 뺄수 있는 값이 된다.
        sum_value += (now - previous) * length 
        length -= 1 # < 다 먹은 음식 '제외' >
        previous = now # 이전 [ 음식 시간을 (현재 시간으로 )재설정 ]

-----------------------------------------------------------------------------------------------------------------------
4. [ 반복문을 나와서 ] 해당 음식들을 다시 ** [ 남은 음식 번호 ] 순으로 정렬 **을 해 준다.
    그리고 [ 남은 음식에서 ] [남은 k만큼을 고려한 ] index 번호를 return 하면 풀이가 끝난다.

( 코드 부분 )
# 남은 음식 중에서 몇 번째 음식인지 확인하여 출력
    result = sorted(q, key=lambda x: x[1]) # [ ** 음식의 번호 ** 기준 ]으로 정렬
    # k = 20, sum_value = 16 --> 20 - 16 = 4초동안 더 먹을수 있다.
    #(  k(중단될 시간) - sum_value(먹기위해 사용한 시간) ) % 남은 음식갯수 
    # 만약 4 % 3 = 1 이되는데, 이게 2, 4, 5 번 음식이 남아 있다고 가정했을때
    # '3'이라는 시간을 쓰고 다시 맨처음 '2'로 돌아오고 먹고나서, 중지가 된뒤 다음의 다시 먹을 음식번호가 '4'가 됨.
    return result[(k - sum_value) % length][1] # 다시먹을 [ '음식 번호'를 출력함. ] --> 그래서 뒤의 배열 [1]을 고정시켜 놓음.