cd C:\Users\choon\OneDrive\Desktop\PythonCodingTest\11_그리디 문제
python "무지의 먹방 라이브.py"
(문제) p, 316~ 317

- 평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 [ 카카오 TV 라이브로 방송 ]을 하기로 마음먹었다.
  그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 [ 독특한 방식을 생각 ]해냈다.

- 회전판에 [ 먹어야 할 N 개의 음식 ]이 있다.
  각 음식에는 [ 1부터 N 까지 번호 ]가 붙어있으며, 각 음식을 섭취하는데 [ 일정 시간이 소요 ]된다.
  무지는 다음과 같은 방법으로 음식을 섭취한다.
  
1. 무지는 [ 1번 음식부터 먹기 시작 ]하며, '회전판'은 [ 번호가 증가하는 순서대로 ] 음식을 무지 앞으로 가져다 놓는다.

2. [ 마지막 번호의 음식을 섭취한 후 ]에는 회전판에 의해 [ 다시 1번 음식이 무지 앞 ]으로 온다.
  
3. 무지는 [ 음식 하나를 1초 동안 섭취 ]한 후 [ 남은 음식은 그대로 두고 ], [ 다음 음식을 섭취 ]한다.
   [ 다음 음식이란 ], 아직 [ 남은 음식 중 다음으로 섭취해야 할 ] [ 가장 가까운 번호의 음식 ]을 말한다.

4. ' 회전판이 다음 음식을 무지 앞으로 ' [ 가져오는데 걸리는 시간은 없다고 가정 ]한다.

- 무지가 먹방을 시작한 지 [ K 초 후에 ] 네트워크 장애로 인해 [ 방송이 잠시 중단 ]되었다.
  무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다.

- 각 음식을 모두 먹는데 [ 필요한 시간이 담겨있는 ] 배열 'food_times',
  [ 네트워크 장애가 발생한 시간 K 초가 ] 매개변수로 주어질 때 
  [ 몇 번 음식부터 다시 섭취하면 되는지 ] return 하도록 solution 함수를 완성하라.

[ 제한사항 ]
  - 'food_times 는' [ 각 음식을 모두 먹는데 필요한 시간 ]이 [ 음식의 번호 순서대로 들어있는 배열 ]이다.
  - ' k 는 ' 방송이 [ 중단된 시간 ]을 나타낸다.
  - 만약 [ 더 섭취해야 할 음식이 없다면 ] '-1을 반환' 하면 된다.

[ 정확성 테스트 제한 사항 ]
  - food_times 의 길이는 1 이상 2,000 이하이다.
  - food_times 의 원소는 1 이상 1,000 이하의 자연수이다.
  - k는 1 이상 2,000,000 이하의 자연수이다.

[ 효율성 테스트 제한 사항 ]
  - food_times 의 [ 길이 ]는 1 이상 200,000 이하이다.
  - food_times 의 [ 원소 ]는 1 이상 100,000,000 이하의 자연수이다.
  - k는 1 이상 2 x 10^13 이하의 자연수이다.

(입출력 예)

food_times	k	result
[3, 1, 2]	5	1

( 입출력 예시에 대한 설명 )

0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.
1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.
2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.
3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.
4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.
5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.
( 아이디어 )

- 단계가 진행됨에 따라 'B의 경우의 수는 ' 줄어듬 --> 이미 계산했던 경우 (조합)는 제외하기 때문.
  ex) 전체 볼링공 개수에서,   [ A의 무게가 i인 볼링공을 선택할 수 있는 개수 ]를 제외해 준다.   --> 이것이 B가 선택하는 경우의 수.

- 각 무게별로 [ 볼링공이 몇 개가 존재하는지 기록 ]할 수 있다. 

 ex) 각 볼링공의 무게 1 3 2 3 2 이라고 할 시
    무게가 1인 볼링공 = 1개
    무게가 2인 볼링공 = 2개
    무게가 3인 볼링공 = 2개
    1. A가 무게가 1인 공을 선택할 때 경우의 수 -> 1 * 4 ( B가 선택할 수 있는 경우의 수 5-1) = 4 
    2. A가 무게가 2인 공을 선택할 때 경우의 수 -> 2 * 2 ( B가 선택할 수 있는 경우의 수 4-2) = 4
    3. A가 무게가 3인 공을 선택할 때 경우의 수 -> 2 * 0 ( B가 선택할 수 있는 경우의 수 2-2) = 0
    => 8가지

( 문제 풀이흐름 )
볼링공 '5개', 최대무게 '3'
각각의 볼링공의 무게 '1 3 2 3 2' 
---------------------------------------------------------------------------------------------------------------
1. 볼링공, 최대무게, 각각의 볼링공의 무게 입력

(코드 부분)
n, m = map(int, input().split()) # 볼링공의 개수, 볼링공의 [ 최대 무게 ] 입력.
data = list(map(int, input().split())) # 볼링공 무게를 입력.

---------------------------------------------------------------------------------------------------------------
2. 1부터 10까지의 각 무게별로 [ 볼링공이 몇 개가 존재하는지 기록 ]할 수 있다. 

(코드 부분 )
array = [0] * 11

for x in data:
    # 각 무게에 해당하는 [ 볼링공의 개수 ] 카운트
    array[x] += 1

[ array 테이블 상황 ]
0 1 2 3 4 5 6 7 8 9 10
---------------------------   
   1 2 2

---------------------------------------------------------------------------------------------------------------

3. '1부터 m(최대무게) 까지 '의 [ 각 무게에 대하여 처리 ] -- 경우의 수 계산
    전체 개수 - [ 무게가 i인 ] 볼링공의 개수(A가 선택할 수 있는 개수) 제외 --> b의 경우의 수가 됨
    ( 'a의 경우의 수' * 'b의 경우의수' ) 계산한 결과를 result 변수에 누적.
   
( 코드 부분 )

result = 0

# 1부터 m(최대무게) 까지의 [ 각 무게에 대하여 처리 ]
for i in range(1, m + 1):
    n -= array[i] # [ 무게가 i인 ] 볼링공의 개수(A가 선택할 수 있는 개수) 제외
    result += array[i] * n # B가 선택하는 경우의 수와 곱해주기

print(result)