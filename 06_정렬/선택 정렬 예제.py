"""
p,157~159
6-1.py 코드
[선택] 정렬
- 매번 가장 작은 것을 선택한다.
- 가장 작은 것을 선택해서 [ 앞으로 보내는 과정을 반복 ]해서 수행.

※ 선택 정렬은 다른 정렬 알고리즘과 비교했을 때 매우 비효율적.
데이터 개수가 10,000개 이상이면 "정렬 속도가 급속히 느려지기" 때문

※ 하지만, 특정한 리스트에서 [ 가장 작은 데이터를 찾는 일이 ] 
   "코딩 테스트에 자주 " 있으므로 "선택 정렬 소스코드 형태에 익숙해질 필요"가 있다.
  그러므로, 선택 정렬 소스코드를 [ 자주 작성해볼 것을 권함 ].
"""

# 내가 푼 방법 
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    temp = 0 # [ 가장 작은 원소의 인덱스 값을 저장 ]받기 위해 사용.
    for j in range(i+1, len(array)): # (N - 1 반복하면서 정렬을 수행.)
        if array[i] > array[j]:
            temp = array[j]     # 작은 값을 저장.
            # 가장 앞의 인덱스에 [ 작은 값을 저장 ], 
            # [작은 값]이 있는 위치에 --> [ 가장 앞의 인덱스 값(더 큰 값) ]을 저장.
            array[i], array[j] = temp, array[i] #스와프
            '''
            # 위와 비슷한 정렬 방법 코드.
            array[j] = array[i] # 오른쪽으로 큰 값을 저장.
            array[i] = temp     # 맨 왼쪽은 작은 값을 저장.
            '''
    print(array) #내가 한 방법이 정렬되어 가는 과정 출력.
            
print("최종 정렬 답", sep='\n')
print(array)
print("------------------------------------------------", sep='\n')
#---------------------------------------------------------------------------

print("책 정답 풀이 흐름 ")
# 책 정답.
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j # [ 가장 작은 원소의 인덱스 값을 구해 ]서 저장.
    #[ 가장 작은 원소의 인덱스 값 ]을, 계속 앞으로 보내며 
    # [ 작은 원소의 인덱스 위치에 ] 가장 앞에 있는 데이터를 저장하여 [ 교환하는 식 ].
    array[i], array[min_index] = array[min_index], array[i] # 스와프
    print(array) #내가 한 방법이 정렬되어 가는 과정 출력.
print("최종 정렬 답", sep='\n')
print(array)