"""
(실전 문제)두 배열의 원소 교체 

- 동빈이는 [ 두 개의 배열 ] A와 B를 가지고 있다.
  두 배열은 [ N개의 원소로 구성 ]되어 있으며, 배열의 [ 원소는 모두 자연수 ]
  
- 동빈이는 " 최대 K번의 바꿔치기 연산을 수행 "할 수 있는데,
  [ 바꿔치기 연산 ]이란 < 배열 A에 있는 원소 하나와 배열 B에 있는 원소 하나를 골라 >서 
  " 두 원소를 서로 바꾸는 것 "을 말한다.

- 동빈이의 최종 목표는 [ 배열 A의 모든 원소의 합이 최대 ]가 되도록 하는 것.

- N, K, 그리고 배열 A와 B의 정보가 주어졌을 때, 
 " 최대 K번의 바꿔치기 연산을 수행 "하여 만들 수 있는 
 [ 배열 A의 모든 원소의 합의 최댓값을 출력 ]하는 프로그램을 작성하시오.  

[ 입력 조건 ]

- 첫째 줄에 N, K가 공백으로 구분되어 입력된다.(1 <= N <=100,000, 0 <= K <= N)

- [ 두 번째 줄 ]에 배열 A의 원소들이 " 공백으로 구분 " 되어 입력된다.
  모든 원소는 10,000,000보다 작은 자연수이다.
- [ 세 번째 줄 ]에 배열 B의 원소들이 " 공백으로 구분 "되어 입력된다.
  모든 원소는 10,000,000보다 작은 자연수이다.

  
[ 출력 조건 ]
- [ 최대 K번의 바꿔치기 연산을 수행 ]하여 만들 수 있는 
  배열 A의 [ 모든 원소의 합의 최댓값을 출력 ]한다.

[ 입력 ]        [ 출력 ]
5 3       

1 2 5 4 3      26

5 5 6 6 5

12 

"""
# 내가 푼 방법.
n, k = map(int,input().split())
print(n, k)
a = list(map(int,input().split()))
b = list(map(int,input().split()))

# a에 원소의 합이 "최대값을 만들기 위해 " 작은것을 앞에 배치해서 
# b의 배열에 큰 값으로 정렬한 뒤 맨앞에서 부터 바꿔치기 연산 수 만큼 
# 원소를 바꿔준다.
a.sort()
b.sort(reverse=True) # 내림 차순 정렬

for i in range(k): #바꿔치기 연산을 수행
    if a[i] < b[i]: #a의 원소가 b의 원소보다 작을경우 [ 두 원소 교체]
        a[i], b[i] = b[i], a[i]
    else :# a의 원소가 크거나 같을때 반복문 탈출
        break
    
print(sum(a)) # a 모든 원소의 합을 출력.

#----------------------------------------------------------------------------------------
# 책 정답.6-12.py p,183~184

n, k = map(int, input().split()) # N과 K를 입력 받기
a = list(map(int, input().split())) # 배열 A의 모든 원소를 입력받기
b = list(map(int, input().split())) # 배열 B의 모든 원소를 입력받기

a.sort() # 배열 A는 오름차순 정렬 수행
b.sort(reverse=True) # 배열 B는 내림차순 정렬 수행

# 첫 번째 인덱스부터 확인하며, 두 배열의 원소를 최대 K번 비교
for i in range(k):
    # A의 원소가 B의 원소보다 작은 경우
    if a[i] < b[i]:
        # 두 원소를 교체
        a[i], b[i] = b[i], a[i]
    else: # A의 원소가 B의 원소보다 크거나 같을 때, 반복문을 탈출
        break

print(sum(a)) # 배열 A의 모든 원소의 합을 출력
